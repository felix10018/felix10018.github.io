(window.webpackJsonp=window.webpackJsonp||[]).push([[122],{615:function(s,t,a){"use strict";a.r(t);var n=a(30),r=Object(n.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"算法之动态规划"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#算法之动态规划"}},[s._v("#")]),s._v(" 算法之动态规划")]),s._v(" "),a("p",[s._v("动态规划（Dynamic Programming）是一种在解决多阶段决策问题时常用的算法思想。")]),s._v(" "),a("p",[s._v("其核心思想是将一个复杂的问题分解成若干个子问题，并通过保存子问题的解来避免重复计算，从而提高算法的效率。")]),s._v(" "),a("p",[s._v("动态规划通常具有以下几个关键步骤：")]),s._v(" "),a("ol",[a("li",[a("p",[s._v("定义状态：确定问题中的状态变量，这些状态变量能够完整地描述问题在不同阶段的情况。")])]),s._v(" "),a("li",[a("p",[s._v("建立状态转移方程：找出不同状态之间的关系，即如何从一个或多个已知的状态推导出当前状态的解。")])]),s._v(" "),a("li",[a("p",[s._v("确定初始状态和边界条件：明确问题的初始情况以及一些特殊情况的处理。")])]),s._v(" "),a("li",[a("p",[s._v("计算最优解：通常通过自底向上或自顶向下的方式，根据状态转移方程逐步计算出最终的最优解。")])])]),s._v(" "),a("p",[s._v("动态规划常用于解决具有最优子结构和重叠子问题性质的问题，例如背包问题、最长公共子序列问题、最长递增子序列问题等。它能够在多项式时间内求解这些问题，相比暴力搜索通常能大大提高效率。")]),s._v(" "),a("h3",{attrs:{id:"核心思想"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#核心思想"}},[s._v("#")]),s._v(" 核心思想")]),s._v(" "),a("p",[s._v("动态规划算法的核心思想可以从以下几个关键方面来理解：")]),s._v(" "),a("ol",[a("li",[a("p",[s._v("最优子结构")]),s._v(" "),a("ul",[a("li",[s._v("意味着一个问题的最优解包含了其子问题的最优解。例如，在计算最长递增子序列时，如果整个序列的最长递增子序列是最优解，那么从序列中的每个位置开始的子序列的最长递增子序列也一定是各自子问题的最优解。")])])]),s._v(" "),a("li",[a("p",[s._v("重叠子问题")]),s._v(" "),a("ul",[a("li",[s._v("指在递归求解问题的过程中，会多次重复计算相同的子问题。动态规划通过保存已经计算过的子问题的结果，避免了重复计算，从而提高效率。")])])]),s._v(" "),a("li",[a("p",[s._v("状态定义与状态转移方程")]),s._v(" "),a("ul",[a("li",[s._v("首先要明确问题的状态是什么，状态应该能够完整地描述问题在某个阶段的情况。然后通过分析问题，找出状态之间的转换关系，即状态转移方程。这个方程用于根据已知的状态计算出新的状态的解。")])])]),s._v(" "),a("li",[a("p",[s._v("无后效性")]),s._v(" "),a("ul",[a("li",[s._v("一旦某个状态的解确定下来，就不会受到后续决策的影响，只与之前的状态有关。")])])]),s._v(" "),a("li",[a("p",[s._v("记忆化搜索或自底向上计算")]),s._v(" "),a("ul",[a("li",[s._v("可以通过记忆化搜索（在递归过程中保存已计算结果）或自底向上的方式（从小规模问题逐步计算出大规模问题的解）来实现动态规划，以获得最终的最优解。")])])])]),s._v(" "),a("p",[s._v("总的来说，动态规划的核心在于巧妙地利用问题的特性，将复杂问题分解为相互关联的子问题，通过保存和利用子问题的解，避免重复计算，最终高效地求出问题的最优解。它要求我们具备敏锐的问题分析能力，准确地定义状态和构建状态转移方程。")]),s._v(" "),a("h3",{attrs:{id:"代码案例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代码案例"}},[s._v("#")]),s._v(" 代码案例")]),s._v(" "),a("p",[s._v("以下是一个使用动态规划计算斐波那契数列的示例代码：")]),s._v(" "),a("div",{staticClass:"language-python line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-python"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("def")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("fibonacci")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n    dp "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("n "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n    dp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v("\n    dp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("for")]),s._v(" i "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("in")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("range")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" n "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n        dp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" dp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("i "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" dp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("i "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" dp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("p",[s._v("这个示例中使用一个数组 "),a("code",[s._v("dp")]),s._v(" 来保存已经计算过的斐波那契数，避免了重复计算，体现了动态规划的思想。")]),s._v(" "),a("p",[s._v("使用动态规划算法解决实际问题的例子：")]),s._v(" "),a("ol",[a("li",[a("p",[a("strong",[s._v("背包问题")]),s._v("：")]),s._v(" "),a("ul",[a("li",[s._v("有一个背包，它有一定的容量限制。同时有若干个物品，每个物品有一定的价值和重量。需要选择一些物品放入背包，使得背包中物品的总价值最大，同时不超过背包的容量。")])])]),s._v(" "),a("li",[a("p",[a("strong",[s._v("最长公共子序列（LCS）问题")]),s._v("：")]),s._v(" "),a("ul",[a("li",[s._v('给定两个字符串，找出它们的最长公共子序列的长度。例如，对于字符串 "ABCDGH" 和 "AEDFHR"，最长公共子序列是 "ADH"，长度为 3 。')])])]),s._v(" "),a("li",[a("p",[a("strong",[s._v("爬楼梯问题")]),s._v("：")]),s._v(" "),a("ul",[a("li",[s._v("假设你正在爬楼梯，每次可以向上爬 1 或 2 个台阶。给定楼梯的总台阶数 n ，计算有多少种不同的方法可以爬到楼顶。")])])]),s._v(" "),a("li",[a("p",[a("strong",[s._v("矩阵连乘问题")]),s._v("：")]),s._v(" "),a("ul",[a("li",[s._v("给定一系列矩阵，需要确定它们相乘的最优顺序（通过添加括号），以使总的乘法运算次数最少。")])])]),s._v(" "),a("li",[a("p",[a("strong",[s._v("编辑距离问题")]),s._v("：")]),s._v(" "),a("ul",[a("li",[s._v("计算将一个字符串转换为另一个字符串所需的最少操作次数（插入、删除或替换字符）。")])])]),s._v(" "),a("li",[a("p",[a("strong",[s._v("股票买卖问题")]),s._v("：")]),s._v(" "),a("ul",[a("li",[s._v("给定一段时间内每天的股票价格，在只允许进行一次买卖的情况下，求出最大利润。")])])])]),s._v(" "),a("p",[s._v("这些例子都可以通过动态规划的方法有效地解决，通过合理定义状态和状态转移方程来求得最优解。")])])}),[],!1,null,null,null);t.default=r.exports}}]);